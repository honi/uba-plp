# Ejercicio 6

## a) `#collect:`

```smalltalk
#(1 2 3 4) collect: [:x | x * 2].
```

```smalltalk
#(2 4 6 8).
```

Es un `map` de funcional.

## b) `#select:`

```smalltalk
#(1 2 3 4) select: [:x | (x mod: 2) = 0 ].
```

```smalltalk
#(2 4).
```

Es un `filter` de funcional.

## c) `#inject: into:`

```smalltalk
#(1 2 3 4) inject: 0 into: [:x :y | x + y ].
```

```smalltalk
10
```

Es un `foldl` de funcional. El argumento `inject:` es el valor inicial, `into:` es el bloque que se ejecuta por cada par de elementos.

## d) `#reduce:` (o `#fold:`)

```smalltalk
#(1 2 3 4) reduce: [:x :y | x + y ].
```

```smalltalk
10
```

Es un `foldl1` de funcional. Falla si la colección está vacía.

## e) `#reduceRight:`

No está implementado en Cuis University, pero supongo que hace un `foldr1`.

## f) `#do:`

```smalltalk
| L1 L2 |
L1 := OrderedCollection withAll: #(1 2 3 4).
L2 := OrderedCollection new.
L1 do: [:x | L2 add: x + 1].
L2.
```

```
an OrderedCollection(2 3 4 5).
```

Agrega todos los elementos de `L1` en `L2` sumándoles `1`.
