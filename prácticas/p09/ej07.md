# Ejercicio 7

Suponiendo que tenemos un objeto `obj` que tiene el siguiente método definido en su clase.

```smalltalk
SomeClass << foo: x
    | aBlock z |
    z := 10.
    aBlock := [x > 5 ifTrue: [z := z + x. ^0] ifFalse: [z := z - x. 5]].
    y := aBlock value.
    y := y + z.
    ^y.
```

**¿Cuál es el resultado de evaluar las siguientes expresiones?**

**a)**

```smalltalk
obj foo: 4.
```

Dentro del método vale `x = 4`. Cuando evaluamos el valor de `aBlock`, `x > 5` es falso entonces se evalúa el valor del argumento `ifFalse:`, puntualmente el bloque `[z := z - x. 5]`. Como `z = 10`, este bloque hace `z := 10 - 4` y luego retorna el número `5`, que se asigna a la variable `y`. La variable `z` ahora vale `6`. Finalmente se ejecuta `y := 5 + 6`, y luego se retorna el valor de `y` que es `11`.

**b)**

```smalltalk
Message selector: #foo: argument: 5.
```

Crea un objeto de la clase `Message` que codifica el mensaje para el selector `foo` con argumento `5`.

Podemos enviar este mensaje de la siguiente forma:

```smalltalk
(Message selector: #foo: argument: 5) sendTo: obj.
```

**c)**

```smalltalk
obj foo: 10.
```

Dentro del método value `x = 10`. Cuando evaluamos el valor de `aBlock`, `x > 5` es verdadero entonces se evalúa el valor del argumento `ifTrue:`, puntualmente el bloque `[z := z + x. ^0]`. Este bloque es interesante porque más allá de la cuentita que hace con `z`, después retorna: `^0`. El símbolo `^` es un return explícito del método, **no** del bloque. Entonces el resultado que obtenemos es `0` ya que no se ejecuta el código que viene después del bloque.
