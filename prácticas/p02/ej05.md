# Práctica 2 / Ejercicio 5

```
     zip :: [a] -> [b] -> [(a,b)]
{Z0} zip = foldr f (const [])
         where f = \x rec ys ->
                   if null ys then []
                   else (x, head ys) : rec (tail ys)

      zip' :: [a] -> [b] -> [(a,b)]
{Z'0} zip' [] ys = []
{Z'1} zip' (x:xs) ys = if null ys then [] else (x, head ys) : zip' xs (tail ys)
```

QVQ: `zip = zip'`

Por principio de extensionalidad funcional basta ver que:

```
∀xs :: [a]. ∀ys :: [b]. zip xs ys = zip' xs ys
```

Inducción estructural sobre listas `xs`.

```
P(xs): zip xs ys = zip' xs ys
```

**Caso base**: `P([])`

```
zip [] ys
= foldr f (const []) [] ys         {Z0}
= const [] ys                      {def foldr}
= []                               {def const}
= zip' [] ys                       {def Z'0}
```

**Caso inductivo**: `∀x :: a. ∀xs :: [a]. P(xs) ⇒ P(x:xs)`

```
zip (x:xs) ys
= foldr f (const []) (x:xs) ys                              {Z0}
= f x (foldr f (const []) xs) ys                            {def foldr}
= if null ys then []
  else (x, head ys) : (foldr f (const []) xs (tail ys))     {def f}
= if null ys then []
  else (x, head ys) : (zip xs (tail ys))                    {Z0}
= if null ys then []
  else (x, head ys) : (zip' xs (tail ys))                   {HI}
= zip' (x:xs) ys                                            {def zip'}
```
