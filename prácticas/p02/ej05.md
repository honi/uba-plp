# Práctica 2 / Ejercicio 5

```
     zip :: [a] -> [b] -> [(a,b)]
{Z0} zip = foldr f (const [])
         where f = \x rec ys ->
                   if null ys then []
                   else (x, head ys) : rec (tail ys)

      zip' :: [a] -> [b] -> [(a,b)]
{Z'0} zip' [] ys = []
{Z'1} zip' (x:xs) ys = if null ys then [] else (x, head ys) : zip' xs (tail ys)
```

QVQ: `zip = zip'`

Por principio de extensionalidad funcional basta ver que:

```
∀xs :: [a]. ∀ys :: [b]. zip xs ys = zip' xs ys
```

Inducción estructural sobre listas `xs` para algún `ys` fijo.

```
P(xs): zip xs ys = zip' xs ys
```

**Caso base**: `P([])`

```
zip' [] ys
= []                            {def zip'}
= const [] ys                   {def const}
= foldr f (const []) [] ys      {def foldr}
= zip [] ys                     {def zip}
```

**Pregunta: borré el ys y luego lo agregué otra vez porque está fijo, vale?**

**Caso inductivo**: `∀x :: a. ∀xs :: [a]. P(xs) ⇒ P(x:xs)`

```
zip' (x:xs) ys
= if null ys then [] else (x, head ys) : zip' xs (tail ys)      {def zip'}
```

Inducción sobre booleanos: `null ys :: Bool`

Caso (1): `null ys = False`

```
= if False then [] else (x, head ys) : zip' xs (tail ys)
= (x, head ys) : zip' xs (tail ys)                              {def if}
```

Caso (2): `null ys = True`

**Preguntar: me trabé**
