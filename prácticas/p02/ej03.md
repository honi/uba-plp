# Práctica 2 / Ejercicio 3

## I.

```
∀xs :: [a]. length (duplicar xs) = 2 * length xs
```

Inducción estructural sobre listas.

```
P(xs): length (duplicar xs) = 2 * length xs
```

**Caso base**: `P([])`

```
length (duplicar [])
= length []                         {def duplicar}
= 0                                 {def length}
= 2 * 0
= 2 * length []                     {def length}
```

**Caso inductivo**: `∀x :: a. ∀xs :: [a]. P(xs) ⇒ P(x:xs)`

```
length (duplicar (x:xs))
= length (x : x : duplicar xs)      {def duplicar}
= 1 + length (x : duplicar xs)      {def length}
= 1 + 1 + length (duplicar xs)      {def length}
= 2 + length (duplicar xs)
= 2 + 2 * length xs                 {HI}
= 2 * (1 + length xs)
= 2 * length (x:xs)                 {def length}
```

## II.

```
∀xs :: [a]. ∀ys :: [a]. length (append xs ys) = length xs + length ys
```

Inducción sobre listas `xs` para algún `ys` fijo.

```
P(xs): length (append xs ys) = length xs + length ys
```

**Caso base**: `P([])`

```
length (append [] ys)
= length ys                     {def append}
= 0 + length ys
= length [] + length ys         {def length}
```

**Caso inductivo**: `∀x :: a. ∀xs :: [a]. P(xs) ⇒ P(x:xs)`

```
length (append (x:xs) ys)
= length (x : append xs ys)     {def append}
= 1 + length (append xs ys)     {def length}
= 1 + length xs + length ys     {HI}
= length (x:xs) + length ys     {def length}
```

## III.

```
∀xs :: [a]. ∀f :: (a -> b). length (map f xs) = length xs
```

Inducción estructural sobre listas.

```
P(xs): length (map f xs) = length xs
```

**Caso base**: `P([])`

```
length (map f [])
= length []                     {def map}
```

**Caso inductivo**: `∀x :: a. ∀xs :: [a]. P(xs) ⇒ P(x:xs)`

```
length (map f (x:xs))
= length (f x : map f xs)       {def map}
= 1 + length (map f xs)         {def length}
= 1 + length xs                 {HI}
= length (x:xs)                 {def length}
```

## IV.

```
Eq a ⇒ ∀xs :: [a]. ∀p :: a -> Bool. ∀e :: a.
(elem e (filter p xs) = True) ⇒ (elem e xs = True)
```

Inducción estructural sobre listas.

**Caso base**: `P([])`

```
elem e (filter p []) = True
= elem e [] = True                                                  {def filter}
= False = True                                                      {def elem}
= False
= False ⇒ (elem e xs = True)                                        {False implica cualquier cosa}
```

**Caso inductivo**: `∀x :: a. ∀xs :: [a]. P(xs) ⇒ P(x:xs)`

```
elem e (filter p (x:xs)) = True
= elem e (if p x then x : filter p xs else filter p xs) = True      {def filter}
```

Inducción sobre booleanos: `p x :: Bool`

Caso (1): `p x = False`

```
= elem e (filter p xs) = True
= (elem e (filter p xs) = True) ⇒ (elem e xs = True)                {por HI}
```

Si `elem e (filter p xs) = False` entonces `False` implica cualquier cosa. \
Si `elem e (filter p xs) = True` significa que `e` se encuentra en `filter p xs ⊆ xs ⊆ x:xs`.

```
= (elem e (filter p xs) = True) ⇒ (elem e x:xs = True)
```

Caso (2): `p x = True`

```
= elem e (x : filter p xs) = True
= (e == x || elem e (filter p xs)) = True                           {def elem}
```

Inducción sobre booleanos: `e == x :: Bool`

Caso (2.1): `(e == x) = False`

```
= (False || elem e (filter p xs)) = True
= elem e (filter p xs) = True                                       {def ||}
= (elem e (filter p xs) = True) ⇒ (elem e xs = True)                {por HI}
= (elem e (filter p xs) = True) ⇒ (elem e x:xs = True)              {por el caso (1)}
```

Caso (2.2): `(e == x) = True`

```
= (True || elem e (filter p xs)) = True
= True = True                                                       {def ||}
= True
```

QVQ: `True ⇒ (elem e x:xs = True)` para que valga `P(x:xs)` \
Basta ver que: `elem e x:xs = True` sabiendo que `e == x`

```
elem e x:xs = True
= (e == x || elem e xs) = True                                      {def elem}
= (True || elem e xs) = True                                        {e == x}
= True = True                                                       {def ||}
= True
```

En todos los casos llegamos a probar que vale `P(xs) ⇒ P(x:xs)`. Probamos entonces que vale `∀xs :: [a]. P(xs)`.

## V.

```
∀xs :: [a]. ∀x :: a. length (ponerAlFinal x xs) = 1 + length xs
```

Para que no se pisen los nombres de las variables en el caso inductivo, probamos la siguiente expresión equivalente donde cambiamos el nombre de `x` por `y`.

```
∀xs :: [a]. ∀y :: a. length (ponerAlFinal y xs) = 1 + length xs
```

Inducción estructural sobre listas.

```
P(xs): length (ponerAlFinal y xs) = 1 + length xs
```

**Caso base**: `P([])`

```
length (ponerAlFinal y [])
= length (foldr (:) (y:[]) [])          {def ponerAlFinal}
= length (y:[])                         {def foldr}
= 1 + length []                         {def length}
```

**Caso inductivo**: `∀x :: a. ∀xs :: [a]. P(xs) ⇒ P(x:xs)`

```
length (ponerAlFinal y (x:xs))
= length (foldr (:) (y:[]) (x:xs))      {def ponerAlFinal}
= length (x : (foldr (:) (y:[]) xs))    {def foldr}
= 1 + length (foldr (:) (y:[]) xs)      {def length}
= 1 + length (ponerAlFinal y xs)        {def ponerAlFinal}
= 1 + 1 + length xs                     {HI}
= 1 + length (x:xs)                     {def length}
```

## VI.

```
∀xs :: [a]. ∀x :: a. head (reverse (ponerAlFinal x xs)) = x
```

Para que no se pisen los nombres de las variables en el caso inductivo, probamos la siguiente expresión equivalente donde cambiamos el nombre de `x` por `y`.

```
∀xs :: [a]. ∀y :: a. head (reverse (ponerAlFinal y xs)) = y
```

Inducción estructural sobre listas.

```
P(xs): head (reverse (ponerAlFinal y xs)) = y
```

**Caso base**: `P([])`

```
head (reverse (ponerAlFinal y []))
= head (reverse (foldr (:) (y:[]) []))          {def ponerAlFinal}
= head (reverse (y:[]))                         {def foldr}
= head (foldl (flip (:)) [] (y:[]))             {def reverse}
= head (foldl (flip (:)) ((flip (:)) [] y) [])  {def foldl (recursivo)}
= head ((flip (:)) [] y)                        {def foldl (caso base)}
= head ((:) y [])                               {def flip}
= y                                             {def head}
```

**Caso inductivo**: `∀x :: a. ∀xs :: [a]. P(xs) ⇒ P(x:xs)`

```
head (reverse (ponerAlFinal y (x:xs)))
= head (reverse (foldr (:) (y:[]) (x:xs)))                          {def ponerAlFinal}
= head (reverse (x : (foldr (:) (y:[]) xs)))                        {def foldr}
= head (reverse (x : (ponerAlFinal y xs)))                          {def ponerAlFinal}
= head (foldl (flip (:)) [] (x : (ponerAlFinal y xs)))              {def reverse}
= head (foldl (flip (:)) ((flip (:)) [] x) (ponerAlFinal y xs))     {def foldl}
= head (foldl (flip (:)) (x:[]) (ponerAlFinal y xs))                {def flip}
```

**Preguntar: necesito probar lema auxiliar**
