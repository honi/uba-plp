# Práctica 2 / Ejercicio 3

## I.

```
∀xs :: [a]. length (duplicar xs) = 2 * length xs
```

Inducción estructural sobre listas.

```
P(xs): length (duplicar xs) = 2 * length xs
```

**Caso base**: `P([])`

```
length (duplicar [])
= length []                         {D0}
= 0                                 {L0}
= 2 * 0
= 2 * length []                     {L0}
```

**Caso inductivo**: `∀x :: a. ∀xs :: [a]. P(xs) ⇒ P(x:xs)`

```
length (duplicar (x:xs))
= length (x : x : duplicar xs)      {D1}
= 1 + length (x : duplicar xs)      {L1}
= 1 + 1 + length (duplicar xs)      {L1}
= 2 + length (duplicar xs)
= 2 + 2 * length xs                 {HI}
= 2 * (1 + length xs)
= 2 * length (x:xs)                 {L1}
```

## II.

```
∀xs :: [a]. ∀ys :: [a]. length (append xs ys) = length xs + length ys
```

Inducción estructural sobre listas `xs`.

```
P(xs): length (append xs ys) = length xs + length ys
```

**Caso base**: `P([])`

```
length (append [] ys)
= length ys                     {A0}
= 0 + length ys
= length [] + length ys         {L0}
```

**Caso inductivo**: `∀x :: a. ∀xs :: [a]. P(xs) ⇒ P(x:xs)`

```
length (append (x:xs) ys)
= length (x : append xs ys)     {A1}
= 1 + length (append xs ys)     {L1}
= 1 + length xs + length ys     {HI}
= length (x:xs) + length ys     {L1}
```

## III.

```
∀xs :: [a]. ∀f :: (a -> b). length (map f xs) = length xs
```

Inducción estructural sobre listas.

```
P(xs): length (map f xs) = length xs
```

**Caso base**: `P([])`

```
length (map f [])
= length []                     {def map}
```

**Caso inductivo**: `∀x :: a. ∀xs :: [a]. P(xs) ⇒ P(x:xs)`

```
length (map f (x:xs))
= length (f x : map f xs)       {def map}
= 1 + length (map f xs)         {L1}
= 1 + length xs                 {HI}
= length (x:xs)                 {L1}
```

## IV.

```
Eq a ⇒ ∀xs :: [a]. ∀p :: a -> Bool. ∀e :: a.
(elem e (filter p xs) = True) ⇒ (elem e xs = True)
```

Inducción estructural sobre listas.

```
P(xs): (elem e (filter p xs) = True) ⇒ (elem e xs = True)
```

**Caso base**: `P([])`

```
elem e (filter p []) = True
= elem e [] = True                                                  {def filter}
= False = True                                                      {def elem}
= False
= False ⇒ (elem e xs = True)                                        {False implica cualquier cosa}
```

**Caso inductivo**: `∀x :: a. ∀xs :: [a]. P(xs) ⇒ P(x:xs)`

```
elem e (filter p (x:xs)) = True
= elem e (if p x then x : filter p xs else filter p xs) = True      {def filter}
```

Inducción sobre booleanos: `p x :: Bool`

Caso (1): `p x = False`

```
= elem e (filter p xs) = True
= (elem e (filter p xs) = True) ⇒ (elem e xs = True)                {por HI}
```

Si `elem e (filter p xs) = False` entonces `False` implica cualquier cosa. \
Si `elem e (filter p xs) = True` significa que `e` se encuentra en `filter p xs ⊆ xs ⊆ x:xs`.

```
= (elem e (filter p xs) = True) ⇒ (elem e x:xs = True)
```

Caso (2): `p x = True`

```
= elem e (x : filter p xs) = True
= (e == x || elem e (filter p xs)) = True                           {def elem}
```

Inducción sobre booleanos: `e == x :: Bool`

Caso (2.1): `(e == x) = False`

```
= (False || elem e (filter p xs)) = True
= elem e (filter p xs) = True                                       {def ||}
= (elem e (filter p xs) = True) ⇒ (elem e xs = True)                {por HI}
= (elem e (filter p xs) = True) ⇒ (elem e x:xs = True)              {por el caso (1)}
```

Caso (2.2): `(e == x) = True`

```
= (True || elem e (filter p xs)) = True
= True = True                                                       {def ||}
= True
```

QVQ: `True ⇒ (elem e x:xs = True)` para que valga `P(x:xs)` \
Basta ver que: `elem e x:xs = True` sabiendo que `e == x`

```
elem e x:xs = True
= (e == x || elem e xs) = True                                      {def elem}
= (True || elem e xs) = True                                        {e == x}
= True = True                                                       {def ||}
= True
```

En todos los casos llegamos a probar que vale `P(xs) ⇒ P(x:xs)`. Probamos entonces que vale `∀xs :: [a]. P(xs)`.

## V.

```
∀xs :: [a]. ∀x :: a. ponerAlFinal x xs = xs ++ (x:[])
```

Sale directo por las definiciones de `ponerAlFinal` y `++`.

```
ponerAlFinal x xs
= foldr (:) (x:[]) xs       {P0}
= xs ++ (x:[])              {++}
```

## VI.

```
reverse = foldr (\x rec -> rec ++ (x:[])) []
```

## VI.

```
∀xs :: [a]. ∀x :: a. head (reverse (ponerAlFinal x xs)) = x
```
